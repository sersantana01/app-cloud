{"remainingRequest":"C:\\Proyectos\\ProyectoX\\Spring3\\sprint3\\app-cloud\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Proyectos\\ProyectoX\\Spring3\\sprint3\\app-cloud\\node_modules\\@stomp\\stompjs\\bundles\\stomp.umd.js","dependencies":[{"path":"C:\\Proyectos\\ProyectoX\\Spring3\\sprint3\\app-cloud\\node_modules\\@stomp\\stompjs\\bundles\\stomp.umd.js","mtime":499162500000},{"path":"C:\\Proyectos\\ProyectoX\\Spring3\\sprint3\\app-cloud\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Proyectos\\ProyectoX\\Spring3\\sprint3\\app-cloud\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1526531406000}],"contextDependencies":[],"result":["/*@__PURE__*/ (function webpackUniversalModuleDefinition(root, factory) {\n    if (typeof exports === 'object' && typeof module === 'object')\n        module.exports = /*@__PURE__*/ factory();\n    else if (typeof define === 'function' && define.amd)\n        /*@__PURE__*/ define(\"StompJs\", [], factory);\n    else if (typeof exports === 'object')\n        exports[\"StompJs\"] = /*@__PURE__*/ factory();\n    else\n        root[\"StompJs\"] = /*@__PURE__*/ factory();\n})(typeof self !== 'undefined' ? self : this, function () {\n    return /******/ (function (modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/\n        /******/ // The require function\n        /******/ function __webpack_require__(moduleId) {\n            /******/\n            /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n                /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n                /******/ \n            };\n            /******/\n            /******/ // Execute the module function\n            /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n            /******/\n            /******/ // Flag the module as loaded\n            /******/ module.l = true;\n            /******/\n            /******/ // Return the exports of the module\n            /******/ return module.exports;\n            /******/ \n        }\n        /******/\n        /******/\n        /******/ // expose the modules object (__webpack_modules__)\n        /******/ __webpack_require__.m = modules;\n        /******/\n        /******/ // expose the module cache\n        /******/ __webpack_require__.c = installedModules;\n        /******/\n        /******/ // define getter function for harmony exports\n        /******/ __webpack_require__.d = function (exports, name, getter) {\n            /******/ if (!__webpack_require__.o(exports, name)) {\n                /******/ Object.defineProperty(exports, name, { enumerable: true, get: getter });\n                /******/ }\n            /******/ \n        };\n        /******/\n        /******/ // define __esModule on exports\n        /******/ __webpack_require__.r = function (exports) {\n            /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n                /******/ }\n            /******/ Object.defineProperty(exports, '__esModule', { value: true });\n            /******/ \n        };\n        /******/\n        /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __webpack_require__.t = function (value, mode) {\n            /******/ if (mode & 1)\n                value = __webpack_require__(value);\n            /******/ if (mode & 8)\n                return value;\n            /******/ if ((mode & 4) && typeof value === 'object' && value && value.__esModule)\n                return value;\n            /******/ var ns = Object.create(null);\n            /******/ __webpack_require__.r(ns);\n            /******/ Object.defineProperty(ns, 'default', { enumerable: true, value: value });\n            /******/ if (mode & 2 && typeof value != 'string')\n                for (var key in value)\n                    __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));\n            /******/ return ns;\n            /******/ \n        };\n        /******/\n        /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __webpack_require__.n = function (module) {\n            /******/ var getter = module && module.__esModule ?\n                /******/ function getDefault() { return module['default']; } :\n                /******/ function getModuleExports() { return module; };\n            /******/ __webpack_require__.d(getter, 'a', getter);\n            /******/ return getter;\n            /******/ \n        };\n        /******/\n        /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n        /******/\n        /******/ // __webpack_public_path__\n        /******/ __webpack_require__.p = \"\";\n        /******/\n        /******/\n        /******/ // Load entry module and return exports\n        /******/ return __webpack_require__(__webpack_require__.s = 0);\n        /******/ \n    })({\n        /***/ \"./src/byte.ts\": \n        /*!*********************!*\\\n          !*** ./src/byte.ts ***!\n          \\*********************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /**\n             * Some byte values, used as per STOMP specifications.\n             *\n             * Part of `@stomp/stompjs`.\n             *\n             * @internal\n             */\n            exports.BYTE = {\n                // LINEFEED byte (octet 10)\n                LF: '\\x0A',\n                // NULL byte (octet 0)\n                NULL: '\\x00'\n            };\n            /***/ \n        }),\n        /***/ \"./src/client.ts\": \n        /*!***********************!*\\\n          !*** ./src/client.ts ***!\n          \\***********************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n                return new (P || (P = Promise))(function (resolve, reject) {\n                    function fulfilled(value) { try {\n                        step(generator.next(value));\n                    }\n                    catch (e) {\n                        reject(e);\n                    } }\n                    function rejected(value) { try {\n                        step(generator[\"throw\"](value));\n                    }\n                    catch (e) {\n                        reject(e);\n                    } }\n                    function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n                    step((generator = generator.apply(thisArg, _arguments || [])).next());\n                });\n            };\n            var __generator = (this && this.__generator) || function (thisArg, body) {\n                var _ = { label: 0, sent: function () { if (t[0] & 1)\n                        throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n                return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () { return this; }), g;\n                function verb(n) { return function (v) { return step([n, v]); }; }\n                function step(op) {\n                    if (f)\n                        throw new TypeError(\"Generator is already executing.\");\n                    while (_)\n                        try {\n                            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n                                return t;\n                            if (y = 0, t)\n                                op = [op[0] & 2, t.value];\n                            switch (op[0]) {\n                                case 0:\n                                case 1:\n                                    t = op;\n                                    break;\n                                case 4:\n                                    _.label++;\n                                    return { value: op[1], done: false };\n                                case 5:\n                                    _.label++;\n                                    y = op[1];\n                                    op = [0];\n                                    continue;\n                                case 7:\n                                    op = _.ops.pop();\n                                    _.trys.pop();\n                                    continue;\n                                default:\n                                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                                        _ = 0;\n                                        continue;\n                                    }\n                                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {\n                                        _.label = op[1];\n                                        break;\n                                    }\n                                    if (op[0] === 6 && _.label < t[1]) {\n                                        _.label = t[1];\n                                        t = op;\n                                        break;\n                                    }\n                                    if (t && _.label < t[2]) {\n                                        _.label = t[2];\n                                        _.ops.push(op);\n                                        break;\n                                    }\n                                    if (t[2])\n                                        _.ops.pop();\n                                    _.trys.pop();\n                                    continue;\n                            }\n                            op = body.call(thisArg, _);\n                        }\n                        catch (e) {\n                            op = [6, e];\n                            y = 0;\n                        }\n                        finally {\n                            f = t = 0;\n                        }\n                    if (op[0] & 5)\n                        throw op[1];\n                    return { value: op[0] ? op[1] : void 0, done: true };\n                }\n            };\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var stomp_handler_1 = __webpack_require__(/*! ./stomp-handler */ \"./src/stomp-handler.ts\");\n            var versions_1 = __webpack_require__(/*! ./versions */ \"./src/versions.ts\");\n            /**\n             * STOMP Client Class.\n             *\n             * Part of `@stomp/stompjs`.\n             */\n            var Client = /*@__PURE__*/ (function () {\n                /**\n                 * Create an instance.\n                 */\n                function Client(conf) {\n                    if (conf === void 0) {\n                        conf = {};\n                    }\n                    /**\n                     * STOMP versions to attempt during STOMP handshake. By default versions `1.0`, `1.1`, and `1.2` are attempted.\n                     *\n                     * Example:\n                     * ```javascript\n                     *        // Try only versions 1.0 and 1.1\n                     *        client.stompVersions = new Versions(['1.0', '1.1'])\n                     * ```\n                     */\n                    this.stompVersions = versions_1.Versions.default;\n                    /**\n                     *  automatically reconnect with delay in milliseconds, set to 0 to disable.\n                     */\n                    this.reconnectDelay = 5000;\n                    /**\n                     * Incoming heartbeat interval in milliseconds. Set to 0 to disable.\n                     */\n                    this.heartbeatIncoming = 10000;\n                    /**\n                     * Outgoing heartbeat interval in milliseconds. Set to 0 to disable.\n                     */\n                    this.heartbeatOutgoing = 10000;\n                    /**\n                     * This switches on a non standard behavior while sending WebSocket packets.\n                     * It splits larger (text) packets into chunks of [maxWebSocketChunkSize]{@link Client#maxWebSocketChunkSize}.\n                     * Only Java Spring brokers seems to use this mode.\n                     *\n                     * WebSockets, by itself, split large (text) packets,\n                     * so it is not needed with a truly compliant STOMP/WebSocket broker.\n                     * Actually setting it for such broker will cause large messages to fail.\n                     *\n                     * `false` by default.\n                     *\n                     * Binary frames are never split.\n                     */\n                    this.splitLargeFrames = false;\n                    /**\n                     * See [splitLargeFrames]{@link Client#splitLargeFrames}.\n                     * This has no effect if [splitLargeFrames]{@link Client#splitLargeFrames} is `false`.\n                     */\n                    this.maxWebSocketChunkSize = 8 * 1024;\n                    /**\n                     * Usually the\n                     * [type of WebSocket frame]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send#Parameters}\n                     * is automatically decided by type of the payload.\n                     * Default is `false`, which should work with all compliant brokers.\n                     *\n                     * Set this flag to force binary frames.\n                     */\n                    this.forceBinaryWSFrames = false;\n                    /**\n                     * A bug in ReactNative chops a string on occurrence of a NULL.\n                     * See issue [https://github.com/stomp-js/stompjs/issues/89]{@link https://github.com/stomp-js/stompjs/issues/89}.\n                     * This makes incoming WebSocket messages invalid STOMP packets.\n                     * Seeting this flag attempts to reverse the damage by appending a NULL.\n                     * If the broker splits a large message into multiple WebSocket messages,\n                     * this flag will cause data loss and abnormal termination of connection.\n                     *\n                     * This is not an ideal solution, but a stop gap until the underlying issue is fixed at ReactNative library.\n                     *\n                     * This flag only impacts handling of text frames.\n                     * Binary frames are not impacted by the underlying issue.\n                     */\n                    this.appendMissingNULLonIncoming = false;\n                    this._active = false;\n                    // Dummy callbacks\n                    var noOp = function () { };\n                    this.debug = noOp;\n                    this.beforeConnect = noOp;\n                    this.onConnect = noOp;\n                    this.onDisconnect = noOp;\n                    this.onUnhandledMessage = noOp;\n                    this.onUnhandledReceipt = noOp;\n                    this.onUnhandledFrame = noOp;\n                    this.onStompError = noOp;\n                    this.onWebSocketClose = noOp;\n                    this.onWebSocketError = noOp;\n                    this.logRawCommunication = false;\n                    // These parameters would typically get proper values before connect is called\n                    this.connectHeaders = {};\n                    this._disconnectHeaders = {};\n                    // Apply configuration\n                    this.configure(conf);\n                }\n                Object.defineProperty(Client.prototype, \"webSocket\", {\n                    /**\n                     * Underlying WebSocket instance, READONLY.\n                     */\n                    get: function () {\n                        return this._webSocket;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(Client.prototype, \"disconnectHeaders\", {\n                    /**\n                     * Disconnection headers.\n                     */\n                    get: function () {\n                        return this._disconnectHeaders;\n                    },\n                    set: function (value) {\n                        this._disconnectHeaders = value;\n                        if (this._stompHandler) {\n                            this._stompHandler.disconnectHeaders = this._disconnectHeaders;\n                        }\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(Client.prototype, \"connected\", {\n                    /**\n                     * `true` if there is a active connection with STOMP Broker\n                     */\n                    get: function () {\n                        return (!!this._stompHandler) && this._stompHandler.connected;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(Client.prototype, \"connectedVersion\", {\n                    /**\n                     * version of STOMP protocol negotiated with the server, READONLY\n                     */\n                    get: function () {\n                        return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(Client.prototype, \"active\", {\n                    /**\n                     * if the client is active (connected or going to reconnect)\n                     */\n                    get: function () {\n                        return this._active;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                /**\n                 * Update configuration.\n                 */\n                Client.prototype.configure = function (conf) {\n                    // bulk assign all properties to this\n                    Object.assign(this, conf);\n                };\n                /**\n                 * Initiate the connection with the broker.\n                 * If the connection breaks, as per [Client#reconnectDelay]{@link Client#reconnectDelay},\n                 * it will keep trying to reconnect.\n                 *\n                 * Call [Client#deactivate]{@link Client#deactivate} to disconnect and stop reconnection attempts.\n                 */\n                Client.prototype.activate = function () {\n                    this._active = true;\n                    this._connect();\n                };\n                Client.prototype._connect = function () {\n                    return __awaiter(this, void 0, void 0, function () {\n                        var _this = this;\n                        return __generator(this, function (_a) {\n                            switch (_a.label) {\n                                case 0:\n                                    if (this.connected) {\n                                        this.debug('STOMP: already connected, nothing to do');\n                                        return [2 /*return*/];\n                                    }\n                                    return [4 /*yield*/, this.beforeConnect()];\n                                case 1:\n                                    _a.sent();\n                                    if (!this._active) {\n                                        this.debug('Client has been marked inactive, will not attempt to connect');\n                                        return [2 /*return*/];\n                                    }\n                                    this.debug('Opening Web Socket...');\n                                    // Get the actual WebSocket (or a similar object)\n                                    this._webSocket = this._createWebSocket();\n                                    this._stompHandler = new stomp_handler_1.StompHandler(this, this._webSocket, {\n                                        debug: this.debug,\n                                        stompVersions: this.stompVersions,\n                                        connectHeaders: this.connectHeaders,\n                                        disconnectHeaders: this._disconnectHeaders,\n                                        heartbeatIncoming: this.heartbeatIncoming,\n                                        heartbeatOutgoing: this.heartbeatOutgoing,\n                                        splitLargeFrames: this.splitLargeFrames,\n                                        maxWebSocketChunkSize: this.maxWebSocketChunkSize,\n                                        forceBinaryWSFrames: this.forceBinaryWSFrames,\n                                        logRawCommunication: this.logRawCommunication,\n                                        onConnect: function (frame) {\n                                            if (!_this._active) {\n                                                _this.debug('STOMP got connected while deactivate was issued, will disconnect now');\n                                                _this._disposeStompHandler();\n                                                return;\n                                            }\n                                            _this.onConnect(frame);\n                                        },\n                                        onDisconnect: function (frame) {\n                                            _this.onDisconnect(frame);\n                                        },\n                                        onStompError: function (frame) {\n                                            _this.onStompError(frame);\n                                        },\n                                        onWebSocketClose: function (evt) {\n                                            _this.onWebSocketClose(evt);\n                                            // The callback is called before attempting to reconnect, this would allow the client\n                                            // to be `deactivated` in the callback.\n                                            if (_this._active) {\n                                                _this._schedule_reconnect();\n                                            }\n                                        },\n                                        onWebSocketError: function (evt) {\n                                            _this.onWebSocketError(evt);\n                                        },\n                                        onUnhandledMessage: function (message) {\n                                            _this.onUnhandledMessage(message);\n                                        },\n                                        onUnhandledReceipt: function (frame) {\n                                            _this.onUnhandledReceipt(frame);\n                                        },\n                                        onUnhandledFrame: function (frame) {\n                                            _this.onUnhandledFrame(frame);\n                                        }\n                                    });\n                                    this._stompHandler.start();\n                                    return [2 /*return*/];\n                            }\n                        });\n                    });\n                };\n                Client.prototype._createWebSocket = function () {\n                    var webSocket;\n                    if (this.webSocketFactory) {\n                        webSocket = this.webSocketFactory();\n                    }\n                    else {\n                        webSocket = new WebSocket(this.brokerURL, this.stompVersions.protocolVersions());\n                    }\n                    webSocket.binaryType = 'arraybuffer';\n                    return webSocket;\n                };\n                Client.prototype._schedule_reconnect = function () {\n                    var _this = this;\n                    if (this.reconnectDelay > 0) {\n                        this.debug(\"STOMP: scheduling reconnection in \" + this.reconnectDelay + \"ms\");\n                        this._reconnector = setTimeout(function () {\n                            _this._connect();\n                        }, this.reconnectDelay);\n                    }\n                };\n                /**\n                 * Disconnect if connected and stop auto reconnect loop.\n                 * Appropriate callbacks will be invoked if underlying STOMP connection was connected.\n                 *\n                 * To reactivate you can call [Client#activate]{@link Client#activate}.\n                 */\n                Client.prototype.deactivate = function () {\n                    // indicate that auto reconnect loop should terminate\n                    this._active = false;\n                    // Clear if a reconnection was scheduled\n                    if (this._reconnector) {\n                        clearTimeout(this._reconnector);\n                    }\n                    this._disposeStompHandler();\n                };\n                /**\n                 * Force disconnect if there is an active connection by directly closing the underlying WebSocket.\n                 * This is different than a normal disconnect where a DISCONNECT sequence is carried out with the broker.\n                 * After forcing disconnect, automatic reconnect will be attempted.\n                 * To stop further reconnects call [Client#deactivate]{@link Client#deactivate} as well.\n                 */\n                Client.prototype.forceDisconnect = function () {\n                    if (this._webSocket) {\n                        if (this._webSocket.readyState === WebSocket.CONNECTING || this._webSocket.readyState === WebSocket.OPEN) {\n                            this._webSocket.close();\n                        }\n                    }\n                };\n                Client.prototype._disposeStompHandler = function () {\n                    // Dispose STOMP Handler\n                    if (this._stompHandler) {\n                        this._stompHandler.dispose();\n                        this._stompHandler = null;\n                    }\n                };\n                /**\n                 * Send a message to a named destination. Refer to your STOMP broker documentation for types\n                 * and naming of destinations.\n                 *\n                 * STOMP protocol specifies and suggests some headers and also allows broker specific headers.\n                 *\n                 * `body` must be String.\n                 * You will need to covert the payload to string in case it is not string (e.g. JSON).\n                 *\n                 * To send a binary message body use binaryBody parameter. It should be a\n                 * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n                 * Sometimes brokers may not support binary frames out of the box.\n                 * Please check your broker documentation.\n                 *\n                 * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n                 * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n                 * For binary messages `content-length` header is always added.\n                 *\n                 * Caution: The broker will, most likely, report an error and disconnect if message body has NULL octet(s)\n                 * and `content-length` header is missing.\n                 *\n                 * ```javascript\n                 *        client.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n                 *\n                 *        // Only destination is mandatory parameter\n                 *        client.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n                 *\n                 *        // Skip content-length header in the frame to the broker\n                 *        client.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n                 *\n                 *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n                 *        // setting content-type header is not mandatory, however a good practice\n                 *        client.publish({destination: '/topic/special', binaryBody: binaryData,\n                 *                         headers: {'content-type': 'application/octet-stream'}});\n                 * ```\n                 */\n                Client.prototype.publish = function (params) {\n                    this._stompHandler.publish(params);\n                };\n                /**\n                 * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n                 * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n                 * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\n                 * random number or a combination may be used.\n                 *\n                 * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n                 * The operation needs to be matched based in the value of the receipt-id.\n                 *\n                 * This method allow watching for a receipt and invoke the callback\n                 * when corresponding receipt has been received.\n                 *\n                 * The actual {@link FrameImpl} will be passed as parameter to the callback.\n                 *\n                 * Example:\n                 * ```javascript\n                 *        // Subscribing with acknowledgement\n                 *        let receiptId = randomText();\n                 *\n                 *        client.watchForReceipt(receiptId, function() {\n                 *          // Will be called after server acknowledges\n                 *        });\n                 *\n                 *        client.subscribe(TEST.destination, onMessage, {receipt: receiptId});\n                 *\n                 *\n                 *        // Publishing with acknowledgement\n                 *        receiptId = randomText();\n                 *\n                 *        client.watchForReceipt(receiptId, function() {\n                 *          // Will be called after server acknowledges\n                 *        });\n                 *        client.publish({destination: TEST.destination, headers: {receipt: receiptId}, body: msg});\n                 * ```\n                 */\n                Client.prototype.watchForReceipt = function (receiptId, callback) {\n                    this._stompHandler.watchForReceipt(receiptId, callback);\n                };\n                /**\n                 * Subscribe to a STOMP Broker location. The callback will be invoked for each received message with\n                 * the {@link IMessage} as argument.\n                 *\n                 * Note: The library will generate an unique ID if there is none provided in the headers.\n                 *       To use your own ID, pass it using the headers argument.\n                 *\n                 * ```javascript\n                 *        callback = function(message) {\n                 *        // called when the client receives a STOMP message from the server\n                 *          if (message.body) {\n                 *            alert(\"got message with body \" + message.body)\n                 *          } else {\n                 *            alert(\"got empty message\");\n                 *          }\n                 *        });\n                 *\n                 *        var subscription = client.subscribe(\"/queue/test\", callback);\n                 *\n                 *        // Explicit subscription id\n                 *        var mySubId = 'my-subscription-id-001';\n                 *        var subscription = client.subscribe(destination, callback, { id: mySubId });\n                 * ```\n                 */\n                Client.prototype.subscribe = function (destination, callback, headers) {\n                    if (headers === void 0) {\n                        headers = {};\n                    }\n                    return this._stompHandler.subscribe(destination, callback, headers);\n                };\n                /**\n                 * It is preferable to unsubscribe from a subscription by calling\n                 * `unsubscribe()` directly on {@link StompSubscription} returned by `client.subscribe()`:\n                 *\n                 * ```javascript\n                 *        var subscription = client.subscribe(destination, onmessage);\n                 *        // ...\n                 *        subscription.unsubscribe();\n                 * ```\n                 *\n                 * See: http://stomp.github.com/stomp-specification-1.2.html#UNSUBSCRIBE UNSUBSCRIBE Frame\n                 */\n                Client.prototype.unsubscribe = function (id, headers) {\n                    if (headers === void 0) {\n                        headers = {};\n                    }\n                    this._stompHandler.unsubscribe(id, headers);\n                };\n                /**\n                 * Start a transaction, the returned {@link ITransaction} has methods - [commit]{@link ITransaction#commit}\n                 * and [abort]{@link ITransaction#abort}.\n                 *\n                 * `transactionId` is optional, if not passed the library will generate it internally.\n                 */\n                Client.prototype.begin = function (transactionId) {\n                    return this._stompHandler.begin(transactionId);\n                };\n                /**\n                 * Commit a transaction.\n                 *\n                 * It is preferable to commit a transaction by calling [commit]{@link ITransaction#commit} directly on\n                 * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n                 *\n                 * ```javascript\n                 *        var tx = client.begin(txId);\n                 *        //...\n                 *        tx.commit();\n                 * ```\n                 */\n                Client.prototype.commit = function (transactionId) {\n                    this._stompHandler.commit(transactionId);\n                };\n                /**\n                 * Abort a transaction.\n                 * It is preferable to abort a transaction by calling [abort]{@link ITransaction#abort} directly on\n                 * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\n                 *\n                 * ```javascript\n                 *        var tx = client.begin(txId);\n                 *        //...\n                 *        tx.abort();\n                 * ```\n                 */\n                Client.prototype.abort = function (transactionId) {\n                    this._stompHandler.abort(transactionId);\n                };\n                /**\n                 * ACK a message. It is preferable to acknowledge a message by calling [ack]{@link IMessage#ack} directly\n                 * on the {@link IMessage} handled by a subscription callback:\n                 *\n                 * ```javascript\n                 *        var callback = function (message) {\n                 *          // process the message\n                 *          // acknowledge it\n                 *          message.ack();\n                 *        };\n                 *        client.subscribe(destination, callback, {'ack': 'client'});\n                 * ```\n                 */\n                Client.prototype.ack = function (messageId, subscriptionId, headers) {\n                    if (headers === void 0) {\n                        headers = {};\n                    }\n                    this._stompHandler.ack(messageId, subscriptionId, headers);\n                };\n                /**\n                 * NACK a message. It is preferable to acknowledge a message by calling [nack]{@link IMessage#nack} directly\n                 * on the {@link IMessage} handled by a subscription callback:\n                 *\n                 * ```javascript\n                 *        var callback = function (message) {\n                 *          // process the message\n                 *          // an error occurs, nack it\n                 *          message.nack();\n                 *        };\n                 *        client.subscribe(destination, callback, {'ack': 'client'});\n                 * ```\n                 */\n                Client.prototype.nack = function (messageId, subscriptionId, headers) {\n                    if (headers === void 0) {\n                        headers = {};\n                    }\n                    this._stompHandler.nack(messageId, subscriptionId, headers);\n                };\n                return Client;\n            }());\n            exports.Client = Client;\n            /***/ \n        }),\n        /***/ \"./src/compatibility/compat-client.ts\": \n        /*!********************************************!*\\\n          !*** ./src/compatibility/compat-client.ts ***!\n          \\********************************************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d, b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                        function (d, b) { for (var p in b)\n                            if (b.hasOwnProperty(p))\n                                d[p] = b[p]; };\n                    return extendStatics(d, b);\n                };\n                return function (d, b) {\n                    extendStatics(d, b);\n                    function __() { this.constructor = d; }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            })();\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var client_1 = __webpack_require__(/*! ../client */ \"./src/client.ts\");\n            var heartbeat_info_1 = __webpack_require__(/*! ./heartbeat-info */ \"./src/compatibility/heartbeat-info.ts\");\n            /**\n             * Available for backward compatibility, please shift to using {@link Client}.\n             *\n             * **Deprecated**\n             *\n             * Part of `@stomp/stompjs`.\n             *\n             * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n             */\n            var CompatClient = /*@__PURE__*/ (function (_super) {\n                __extends(CompatClient, _super);\n                /**\n                 * Available for backward compatibility, please shift to using {@link Client}\n                 * and [Client#webSocketFactory]{@link Client#webSocketFactory}.\n                 *\n                 * **Deprecated**\n                 *\n                 * @internal\n                 */\n                function CompatClient(webSocketFactory) {\n                    var _this = _super.call(this) || this;\n                    /**\n                     * It is no op now. No longer needed. Large packets work out of the box.\n                     */\n                    _this.maxWebSocketFrameSize = 16 * 1024;\n                    _this._heartbeatInfo = new heartbeat_info_1.HeartbeatInfo(_this);\n                    _this.reconnect_delay = 0;\n                    _this.webSocketFactory = webSocketFactory;\n                    // Default from previous version\n                    _this.debug = function () {\n                        var message = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            message[_i] = arguments[_i];\n                        }\n                        console.log.apply(console, message);\n                    };\n                    return _this;\n                }\n                CompatClient.prototype._parseConnect = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    var closeEventCallback;\n                    var connectCallback;\n                    var errorCallback;\n                    var headers = {};\n                    if (args.length < 2) {\n                        throw new Error(('Connect requires at least 2 arguments'));\n                    }\n                    if (typeof (args[1]) === 'function') {\n                        headers = args[0], connectCallback = args[1], errorCallback = args[2], closeEventCallback = args[3];\n                    }\n                    else {\n                        switch (args.length) {\n                            case 6:\n                                headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], closeEventCallback = args[4], headers.host = args[5];\n                                break;\n                            default:\n                                headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], closeEventCallback = args[4];\n                        }\n                    }\n                    return [headers, connectCallback, errorCallback, closeEventCallback];\n                };\n                /**\n                 * Available for backward compatibility, please shift to using [Client#activate]{@link Client#activate}.\n                 *\n                 * **Deprecated**\n                 *\n                 * The `connect` method accepts different number of arguments and types. See the Overloads list. Use the\n                 * version with headers to pass your broker specific options.\n                 *\n                 * overloads:\n                 * - connect(headers, connectCallback)\n                 * - connect(headers, connectCallback, errorCallback)\n                 * - connect(login, passcode, connectCallback)\n                 * - connect(login, passcode, connectCallback, errorCallback)\n                 * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback)\n                 * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback, host)\n                 *\n                 * params:\n                 * - headers, see [Client#connectHeaders]{@link Client#connectHeaders}\n                 * - connectCallback, see [Client#onConnect]{@link Client#onConnect}\n                 * - errorCallback, see [Client#onStompError]{@link Client#onStompError}\n                 * - closeEventCallback, see [Client#onWebSocketClose]{@link Client#onWebSocketClose}\n                 * - login [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n                 * - passcode [String], [Client#connectHeaders](../classes/Client.html#connectHeaders)\n                 * - host [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\n                 *\n                 * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n                 */\n                CompatClient.prototype.connect = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    var out = this._parseConnect.apply(this, args);\n                    if (out[0]) {\n                        this.connectHeaders = out[0];\n                    }\n                    if (out[1]) {\n                        this.onConnect = out[1];\n                    }\n                    if (out[2]) {\n                        this.onStompError = out[2];\n                    }\n                    if (out[3]) {\n                        this.onWebSocketClose = out[3];\n                    }\n                    _super.prototype.activate.call(this);\n                };\n                /**\n                 * Available for backward compatibility, please shift to using [Client#deactivate]{@link Client#deactivate}.\n                 *\n                 * **Deprecated**\n                 *\n                 * See:\n                 * [Client#onDisconnect]{@link Client#onDisconnect}, and\n                 * [Client#disconnectHeaders]{@link Client#disconnectHeaders}\n                 *\n                 * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n                 */\n                CompatClient.prototype.disconnect = function (disconnectCallback, headers) {\n                    if (headers === void 0) {\n                        headers = {};\n                    }\n                    if (disconnectCallback) {\n                        this.onDisconnect = disconnectCallback;\n                    }\n                    this.disconnectHeaders = headers;\n                    _super.prototype.deactivate.call(this);\n                };\n                /**\n                 * Available for backward compatibility, use [Client#publish]{@link Client#publish}.\n                 *\n                 * Send a message to a named destination. Refer to your STOMP broker documentation for types\n                 * and naming of destinations. The headers will, typically, be available to the subscriber.\n                 * However, there may be special purpose headers corresponding to your STOMP broker.\n                 *\n                 *  **Deprecated**, use [Client#publish]{@link Client#publish}\n                 *\n                 * Note: Body must be String. You will need to covert the payload to string in case it is not string (e.g. JSON)\n                 *\n                 * ```javascript\n                 *        client.send(\"/queue/test\", {priority: 9}, \"Hello, STOMP\");\n                 *\n                 *        // If you want to send a message with a body, you must also pass the headers argument.\n                 *        client.send(\"/queue/test\", {}, \"Hello, STOMP\");\n                 * ```\n                 *\n                 * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\n                 */\n                CompatClient.prototype.send = function (destination, headers, body) {\n                    if (headers === void 0) {\n                        headers = {};\n                    }\n                    if (body === void 0) {\n                        body = '';\n                    }\n                    headers = Object.assign({}, headers);\n                    var skipContentLengthHeader = (headers['content-length'] === false);\n                    if (skipContentLengthHeader) {\n                        delete headers['content-length'];\n                    }\n                    this.publish({\n                        destination: destination,\n                        headers: headers,\n                        body: body,\n                        skipContentLengthHeader: skipContentLengthHeader\n                    });\n                };\n                Object.defineProperty(CompatClient.prototype, \"reconnect_delay\", {\n                    /**\n                     * Available for backward compatibility, renamed to [Client#reconnectDelay]{@link Client#reconnectDelay}.\n                     *\n                     * **Deprecated**\n                     */\n                    set: function (value) {\n                        this.reconnectDelay = value;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(CompatClient.prototype, \"ws\", {\n                    /**\n                     * Available for backward compatibility, renamed to [Client#webSocket]{@link Client#webSocket}.\n                     *\n                     * **Deprecated**\n                     */\n                    get: function () {\n                        return this._webSocket;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(CompatClient.prototype, \"version\", {\n                    /**\n                     * Available for backward compatibility, renamed to [Client#connectedVersion]{@link Client#connectedVersion}.\n                     *\n                     * **Deprecated**\n                     */\n                    get: function () {\n                        return this.connectedVersion;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(CompatClient.prototype, \"onreceive\", {\n                    /**\n                     * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n                     *\n                     * **Deprecated**\n                     */\n                    get: function () {\n                        return this.onUnhandledMessage;\n                    },\n                    /**\n                     * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\n                     *\n                     * **Deprecated**\n                     */\n                    set: function (value) {\n                        this.onUnhandledMessage = value;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(CompatClient.prototype, \"onreceipt\", {\n                    /**\n                     * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n                     * Prefer using [Client#watchForReceipt]{@link Client#watchForReceipt}.\n                     *\n                     * **Deprecated**\n                     */\n                    get: function () {\n                        return this.onUnhandledReceipt;\n                    },\n                    /**\n                     * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\n                     *\n                     * **Deprecated**\n                     */\n                    set: function (value) {\n                        this.onUnhandledReceipt = value;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(CompatClient.prototype, \"heartbeat\", {\n                    /**\n                     * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n                     * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n                     *\n                     * **Deprecated**\n                     */\n                    get: function () {\n                        return this._heartbeatInfo;\n                    },\n                    /**\n                     * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\n                     * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\n                     *\n                     * **Deprecated**\n                     */\n                    set: function (value) {\n                        this.heartbeatIncoming = value.incoming;\n                        this.heartbeatOutgoing = value.outgoing;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return CompatClient;\n            }(client_1.Client));\n            exports.CompatClient = CompatClient;\n            /***/ \n        }),\n        /***/ \"./src/compatibility/heartbeat-info.ts\": \n        /*!*********************************************!*\\\n          !*** ./src/compatibility/heartbeat-info.ts ***!\n          \\*********************************************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /**\n             * Part of `@stomp/stompjs`.\n             *\n             * @internal\n             */\n            var HeartbeatInfo = /*@__PURE__*/ (function () {\n                function HeartbeatInfo(client) {\n                    this.client = client;\n                }\n                Object.defineProperty(HeartbeatInfo.prototype, \"outgoing\", {\n                    get: function () {\n                        return this.client.heartbeatOutgoing;\n                    },\n                    set: function (value) {\n                        this.client.heartbeatOutgoing = value;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(HeartbeatInfo.prototype, \"incoming\", {\n                    get: function () {\n                        return this.client.heartbeatIncoming;\n                    },\n                    set: function (value) {\n                        this.client.heartbeatIncoming = value;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return HeartbeatInfo;\n            }());\n            exports.HeartbeatInfo = HeartbeatInfo;\n            /***/ \n        }),\n        /***/ \"./src/compatibility/stomp.ts\": \n        /*!************************************!*\\\n          !*** ./src/compatibility/stomp.ts ***!\n          \\************************************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var versions_1 = __webpack_require__(/*! ../versions */ \"./src/versions.ts\");\n            var compat_client_1 = __webpack_require__(/*! ./compat-client */ \"./src/compatibility/compat-client.ts\");\n            /**\n             * STOMP Class, acts like a factory to create {@link Client}.\n             *\n             * Part of `@stomp/stompjs`.\n             *\n             * **Deprecated**\n             *\n             * It will be removed in next major version. Please switch to {@link Client}.\n             */\n            var Stomp = /*@__PURE__*/ (function () {\n                function Stomp() {\n                }\n                /**\n                 * This method creates a WebSocket client that is connected to\n                 * the STOMP server located at the url.\n                 *\n                 * ```javascript\n                 *        var url = \"ws://localhost:61614/stomp\";\n                 *        var client = Stomp.client(url);\n                 * ```\n                 *\n                 * **Deprecated**\n                 *\n                 * It will be removed in next major version. Please switch to {@link Client}\n                 * using [Client#brokerURL]{@link Client#brokerURL}.\n                 */\n                Stomp.client = function (url, protocols) {\n                    // This is a hack to allow another implementation than the standard\n                    // HTML5 WebSocket class.\n                    //\n                    // It is possible to use another class by calling\n                    //\n                    //     Stomp.WebSocketClass = MozWebSocket\n                    //\n                    // *prior* to call `Stomp.client()`.\n                    //\n                    // This hack is deprecated and `Stomp.over()` method should be used\n                    // instead.\n                    // See remarks on the function Stomp.over\n                    if (protocols == null) {\n                        protocols = versions_1.Versions.default.protocolVersions();\n                    }\n                    var wsFn = function () {\n                        var klass = Stomp.WebSocketClass || WebSocket;\n                        return new klass(url, protocols);\n                    };\n                    return new compat_client_1.CompatClient(wsFn);\n                };\n                /**\n                 * This method is an alternative to [Stomp#client]{@link Stomp#client} to let the user\n                 * specify the WebSocket to use (either a standard HTML5 WebSocket or\n                 * a similar object).\n                 *\n                 * In order to support reconnection, the function Client._connect should be callable more than once.\n                 * While reconnecting\n                 * a new instance of underlying transport (TCP Socket, WebSocket or SockJS) will be needed. So, this function\n                 * alternatively allows passing a function that should return a new instance of the underlying socket.\n                 *\n                 * ```javascript\n                 *        var client = Stomp.over(function(){\n                 *          return new WebSocket('ws://localhost:15674/ws')\n                 *        });\n                 * ```\n                 *\n                 * **Deprecated**\n                 *\n                 * It will be removed in next major version. Please switch to {@link Client}\n                 * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n                 */\n                Stomp.over = function (ws) {\n                    var wsFn = typeof (ws) === 'function' ? ws : function () { return ws; };\n                    return new compat_client_1.CompatClient(wsFn);\n                };\n                /**\n                 * In case you need to use a non standard class for WebSocket.\n                 *\n                 * For example when using within NodeJS environment:\n                 *\n                 * ```javascript\n                 *        StompJs = require('../../esm5/');\n                 *        Stomp = StompJs.Stomp;\n                 *        Stomp.WebSocketClass = require('websocket').w3cwebsocket;\n                 * ```\n                 *\n                 * **Deprecated**\n                 *\n                 *\n                 * It will be removed in next major version. Please switch to {@link Client}\n                 * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\n                 */\n                // tslint:disable-next-line:variable-name\n                Stomp.WebSocketClass = null;\n                return Stomp;\n            }());\n            exports.Stomp = Stomp;\n            /***/ \n        }),\n        /***/ \"./src/frame-impl.ts\": \n        /*!***************************!*\\\n          !*** ./src/frame-impl.ts ***!\n          \\***************************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var byte_1 = __webpack_require__(/*! ./byte */ \"./src/byte.ts\");\n            /**\n             * Frame class represents a STOMP frame.\n             *\n             * @internal\n             */\n            var FrameImpl = /*@__PURE__*/ (function () {\n                /**\n                 * Frame constructor. `command`, `headers` and `body` are available as properties.\n                 *\n                 * @internal\n                 */\n                function FrameImpl(params) {\n                    var command = params.command, headers = params.headers, body = params.body, binaryBody = params.binaryBody, escapeHeaderValues = params.escapeHeaderValues, skipContentLengthHeader = params.skipContentLengthHeader;\n                    this.command = command;\n                    this.headers = Object.assign({}, headers || {});\n                    if (binaryBody) {\n                        this._binaryBody = binaryBody;\n                        this.isBinaryBody = true;\n                    }\n                    else {\n                        this._body = body || '';\n                        this.isBinaryBody = false;\n                    }\n                    this.escapeHeaderValues = escapeHeaderValues || false;\n                    this.skipContentLengthHeader = skipContentLengthHeader || false;\n                }\n                Object.defineProperty(FrameImpl.prototype, \"body\", {\n                    /**\n                     * body of the frame\n                     */\n                    get: function () {\n                        if (!this._body && this.isBinaryBody) {\n                            this._body = new TextDecoder().decode(this._binaryBody);\n                        }\n                        return this._body;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(FrameImpl.prototype, \"binaryBody\", {\n                    /**\n                     * body as Uint8Array\n                     */\n                    get: function () {\n                        if (!this._binaryBody && !this.isBinaryBody) {\n                            this._binaryBody = new TextEncoder().encode(this._body);\n                        }\n                        return this._binaryBody;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                /**\n                 * deserialize a STOMP Frame from raw data.\n                 *\n                 * @internal\n                 */\n                FrameImpl.fromRawFrame = function (rawFrame, escapeHeaderValues) {\n                    var headers = {};\n                    var trim = function (str) { return str.replace(/^\\s+|\\s+$/g, ''); };\n                    // In case of repeated headers, as per standards, first value need to be used\n                    for (var _i = 0, _a = rawFrame.headers.reverse(); _i < _a.length; _i++) {\n                        var header = _a[_i];\n                        var idx = header.indexOf(':');\n                        var key = trim(header[0]);\n                        var value = trim(header[1]);\n                        if (escapeHeaderValues && (rawFrame.command !== 'CONNECT') && (rawFrame.command !== 'CONNECTED')) {\n                            value = FrameImpl.hdrValueUnEscape(value);\n                        }\n                        headers[key] = value;\n                    }\n                    return new FrameImpl({\n                        command: rawFrame.command,\n                        headers: headers,\n                        binaryBody: rawFrame.binaryBody,\n                        escapeHeaderValues: escapeHeaderValues\n                    });\n                };\n                /**\n                 * @internal\n                 */\n                FrameImpl.prototype.toString = function () {\n                    return this.serializeCmdAndHeaders();\n                };\n                /**\n                 * serialize this Frame in a format suitable to be passed to WebSocket.\n                 * If the body is string the output will be string.\n                 * If the body is binary (i.e. of type Unit8Array) it will be serialized to ArrayBuffer.\n                 *\n                 * @internal\n                 */\n                FrameImpl.prototype.serialize = function () {\n                    var cmdAndHeaders = this.serializeCmdAndHeaders();\n                    if (this.isBinaryBody) {\n                        return FrameImpl.toUnit8Array(cmdAndHeaders, this._binaryBody).buffer;\n                    }\n                    else {\n                        return cmdAndHeaders + this._body + byte_1.BYTE.NULL;\n                    }\n                };\n                FrameImpl.prototype.serializeCmdAndHeaders = function () {\n                    var lines = [this.command];\n                    if (this.skipContentLengthHeader) {\n                        delete this.headers['content-length'];\n                    }\n                    for (var _i = 0, _a = Object.keys(this.headers || {}); _i < _a.length; _i++) {\n                        var name_1 = _a[_i];\n                        var value = this.headers[name_1];\n                        if (this.escapeHeaderValues && (this.command !== 'CONNECT') && (this.command !== 'CONNECTED')) {\n                            lines.push(name_1 + \":\" + FrameImpl.hdrValueEscape(\"\" + value));\n                        }\n                        else {\n                            lines.push(name_1 + \":\" + value);\n                        }\n                    }\n                    if (this.isBinaryBody || (!this.isBodyEmpty() && !this.skipContentLengthHeader)) {\n                        lines.push(\"content-length:\" + this.bodyLength());\n                    }\n                    return lines.join(byte_1.BYTE.LF) + byte_1.BYTE.LF + byte_1.BYTE.LF;\n                };\n                FrameImpl.prototype.isBodyEmpty = function () {\n                    return this.bodyLength() === 0;\n                };\n                FrameImpl.prototype.bodyLength = function () {\n                    var binaryBody = this.binaryBody;\n                    return binaryBody ? binaryBody.length : 0;\n                };\n                /**\n                 * Compute the size of a UTF-8 string by counting its number of bytes\n                 * (and not the number of characters composing the string)\n                 */\n                FrameImpl.sizeOfUTF8 = function (s) {\n                    return s ? new TextEncoder().encode(s).length : 0;\n                };\n                FrameImpl.toUnit8Array = function (cmdAndHeaders, binaryBody) {\n                    var uint8CmdAndHeaders = new TextEncoder().encode(cmdAndHeaders);\n                    var nullTerminator = new Uint8Array([0]);\n                    var uint8Frame = new Uint8Array(uint8CmdAndHeaders.length + binaryBody.length + nullTerminator.length);\n                    uint8Frame.set(uint8CmdAndHeaders);\n                    uint8Frame.set(binaryBody, uint8CmdAndHeaders.length);\n                    uint8Frame.set(nullTerminator, uint8CmdAndHeaders.length + binaryBody.length);\n                    return uint8Frame;\n                };\n                /**\n                 * Serialize a STOMP frame as per STOMP standards, suitable to be sent to the STOMP broker.\n                 *\n                 * @internal\n                 */\n                FrameImpl.marshall = function (params) {\n                    var frame = new FrameImpl(params);\n                    return frame.serialize();\n                };\n                /**\n                 *  Escape header values\n                 */\n                FrameImpl.hdrValueEscape = function (str) {\n                    return str.replace(/\\\\/g, '\\\\\\\\').replace(/\\r/g, '\\\\r').replace(/\\n/g, '\\\\n').replace(/:/g, '\\\\c');\n                };\n                /**\n                 * UnEscape header values\n                 */\n                FrameImpl.hdrValueUnEscape = function (str) {\n                    return str.replace(/\\\\r/g, '\\r').replace(/\\\\n/g, '\\n').replace(/\\\\c/g, ':').replace(/\\\\\\\\/g, '\\\\');\n                };\n                return FrameImpl;\n            }());\n            exports.FrameImpl = FrameImpl;\n            /***/ \n        }),\n        /***/ \"./src/index.ts\": \n        /*!**********************!*\\\n          !*** ./src/index.ts ***!\n          \\**********************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            function __export(m) {\n                for (var p in m)\n                    if (!exports.hasOwnProperty(p))\n                        exports[p] = m[p];\n            }\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            __export(__webpack_require__(/*! ./client */ \"./src/client.ts\"));\n            __export(__webpack_require__(/*! ./frame-impl */ \"./src/frame-impl.ts\"));\n            __export(__webpack_require__(/*! ./parser */ \"./src/parser.ts\"));\n            __export(__webpack_require__(/*! ./stomp-config */ \"./src/stomp-config.ts\"));\n            __export(__webpack_require__(/*! ./stomp-headers */ \"./src/stomp-headers.ts\"));\n            __export(__webpack_require__(/*! ./stomp-subscription */ \"./src/stomp-subscription.ts\"));\n            __export(__webpack_require__(/*! ./versions */ \"./src/versions.ts\"));\n            // Compatibility code\n            __export(__webpack_require__(/*! ./compatibility/compat-client */ \"./src/compatibility/compat-client.ts\"));\n            __export(__webpack_require__(/*! ./compatibility/stomp */ \"./src/compatibility/stomp.ts\"));\n            /***/ \n        }),\n        /***/ \"./src/parser.ts\": \n        /*!***********************!*\\\n          !*** ./src/parser.ts ***!\n          \\***********************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /**\n             * @internal\n             */\n            var NULL = 0;\n            /**\n             * @internal\n             */\n            var LF = 10;\n            /**\n             * @internal\n             */\n            var CR = 13;\n            /**\n             * @internal\n             */\n            var COLON = 58;\n            /**\n             * This is an evented, rec descent parser.\n             * A stream of Octets can be passed and whenever it recognizes\n             * a complete Frame or an incoming ping it will invoke the registered callbacks.\n             *\n             * All incoming Octets are fed into _onByte function.\n             * Depending on current state the _onByte function keeps changing.\n             * Depending on the state it keeps accumulating into _token and _results.\n             * State is indicated by current value of _onByte, all states are named as _collect.\n             *\n             * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n             * imply that all lengths are considered in bytes (instead of string lengths).\n             * So, before actual parsing, if the incoming data is String it is converted to Octets.\n             * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n             *\n             * There is no peek function on the incoming data.\n             * When a state change occurs based on an Octet without consuming the Octet,\n             * the Octet, after state change, is fed again (_reinjectByte).\n             * This became possible as the state change can be determined by inspecting just one Octet.\n             *\n             * There are two modes to collect the body, if content-length header is there then it by counting Octets\n             * otherwise it is determined by NULL terminator.\n             *\n             * Following the standards, the command and headers are converted to Strings\n             * and the body is returned as Octets.\n             * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n             *\n             * This parser does not use Regular Expressions as that can only operate on Strings.\n             *\n             * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n             * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n             * is pushed.\n             *\n             * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n             * (which is protocol version specific), and convert body to text.\n             *\n             * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n             *\n             * Part of `@stomp/stompjs`.\n             *\n             * @internal\n             */\n            var Parser = /*@__PURE__*/ (function () {\n                function Parser(onFrame, onIncomingPing) {\n                    this.onFrame = onFrame;\n                    this.onIncomingPing = onIncomingPing;\n                    this._encoder = new TextEncoder();\n                    this._decoder = new TextDecoder();\n                    this._token = [];\n                    this._initState();\n                }\n                Parser.prototype.parseChunk = function (segment) {\n                    var chunk;\n                    if ((segment instanceof ArrayBuffer)) {\n                        chunk = new Uint8Array(segment);\n                    }\n                    else {\n                        chunk = this._encoder.encode(segment);\n                    }\n                    // tslint:disable-next-line:prefer-for-of\n                    for (var i = 0; i < chunk.length; i++) {\n                        var byte = chunk[i];\n                        this._onByte(byte);\n                    }\n                };\n                // The following implements a simple Rec Descent Parser.\n                // The grammar is simple and just one byte tells what should be the next state\n                Parser.prototype._collectFrame = function (byte) {\n                    if (byte === NULL) {\n                        return;\n                    }\n                    if (byte === CR) {\n                        return;\n                    }\n                    if (byte === LF) {\n                        this.onIncomingPing();\n                        return;\n                    }\n                    this._onByte = this._collectCommand;\n                    this._reinjectByte(byte);\n                };\n                Parser.prototype._collectCommand = function (byte) {\n                    if (byte === CR) {\n                        return;\n                    }\n                    if (byte === LF) {\n                        this._results.command = this._consumeTokenAsUTF8();\n                        this._onByte = this._collectHeaders;\n                        return;\n                    }\n                    this._consumeByte(byte);\n                };\n                Parser.prototype._collectHeaders = function (byte) {\n                    if (byte === CR) {\n                        return;\n                    }\n                    if (byte === LF) {\n                        this._setupCollectBody();\n                        return;\n                    }\n                    this._onByte = this._collectHeaderKey;\n                    this._reinjectByte(byte);\n                };\n                Parser.prototype._reinjectByte = function (byte) {\n                    this._onByte(byte);\n                };\n                Parser.prototype._collectHeaderKey = function (byte) {\n                    if (byte === COLON) {\n                        this._headerKey = this._consumeTokenAsUTF8();\n                        this._onByte = this._collectHeaderValue;\n                        return;\n                    }\n                    this._consumeByte(byte);\n                };\n                Parser.prototype._collectHeaderValue = function (byte) {\n                    if (byte === CR) {\n                        return;\n                    }\n                    if (byte === LF) {\n                        this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]);\n                        this._headerKey = undefined;\n                        this._onByte = this._collectHeaders;\n                        return;\n                    }\n                    this._consumeByte(byte);\n                };\n                Parser.prototype._setupCollectBody = function () {\n                    var contentLengthHeader = this._results.headers.filter(function (header) {\n                        return header[0] === 'content-length';\n                    })[0];\n                    if (contentLengthHeader) {\n                        this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n                        this._onByte = this._collectBodyFixedSize;\n                    }\n                    else {\n                        this._onByte = this._collectBodyNullTerminated;\n                    }\n                };\n                Parser.prototype._collectBodyNullTerminated = function (byte) {\n                    if (byte === NULL) {\n                        this._retrievedBody();\n                        return;\n                    }\n                    this._consumeByte(byte);\n                };\n                Parser.prototype._collectBodyFixedSize = function (byte) {\n                    // It is post decrement, so that we discard the trailing NULL octet\n                    if (this._bodyBytesRemaining-- === 0) {\n                        this._retrievedBody();\n                        return;\n                    }\n                    this._consumeByte(byte);\n                };\n                Parser.prototype._retrievedBody = function () {\n                    this._results.binaryBody = this._consumeTokenAsRaw();\n                    this.onFrame(this._results);\n                    this._initState();\n                };\n                // Rec Descent Parser helpers\n                Parser.prototype._consumeByte = function (byte) {\n                    this._token.push(byte);\n                };\n                Parser.prototype._consumeTokenAsUTF8 = function () {\n                    return this._decoder.decode(this._consumeTokenAsRaw());\n                };\n                Parser.prototype._consumeTokenAsRaw = function () {\n                    var rawResult = new Uint8Array(this._token);\n                    this._token = [];\n                    return rawResult;\n                };\n                Parser.prototype._initState = function () {\n                    this._results = {\n                        command: undefined,\n                        headers: [],\n                        binaryBody: undefined\n                    };\n                    this._token = [];\n                    this._headerKey = undefined;\n                    this._onByte = this._collectFrame;\n                };\n                return Parser;\n            }());\n            exports.Parser = Parser;\n            /***/ \n        }),\n        /***/ \"./src/stomp-config.ts\": \n        /*!*****************************!*\\\n          !*** ./src/stomp-config.ts ***!\n          \\*****************************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /**\n             * Configuration options for STOMP Client, each key corresponds to\n             * field by the same name in {@link Client}. This can be passed to\n             * the constructor of {@link Client} or to [Client#configure]{@link Client#configure}.\n             *\n             * Part of `@stomp/stompjs`.\n             */\n            var StompConfig = /*@__PURE__*/ (function () {\n                function StompConfig() {\n                }\n                return StompConfig;\n            }());\n            exports.StompConfig = StompConfig;\n            /***/ \n        }),\n        /***/ \"./src/stomp-handler.ts\": \n        /*!******************************!*\\\n          !*** ./src/stomp-handler.ts ***!\n          \\******************************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            var byte_1 = __webpack_require__(/*! ./byte */ \"./src/byte.ts\");\n            var frame_impl_1 = __webpack_require__(/*! ./frame-impl */ \"./src/frame-impl.ts\");\n            var parser_1 = __webpack_require__(/*! ./parser */ \"./src/parser.ts\");\n            var versions_1 = __webpack_require__(/*! ./versions */ \"./src/versions.ts\");\n            /**\n             * The STOMP protocol handler\n             *\n             * Part of `@stomp/stompjs`.\n             *\n             * @internal\n             */\n            var StompHandler = /*@__PURE__*/ (function () {\n                function StompHandler(_client, _webSocket, config) {\n                    if (config === void 0) {\n                        config = {};\n                    }\n                    var _this = this;\n                    this._client = _client;\n                    this._webSocket = _webSocket;\n                    this._serverFrameHandlers = {\n                        // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\n                        CONNECTED: function (frame) {\n                            _this.debug(\"connected to server \" + frame.headers.server);\n                            _this._connected = true;\n                            _this._connectedVersion = frame.headers.version;\n                            // STOMP version 1.2 needs header values to be escaped\n                            if (_this._connectedVersion === versions_1.Versions.V1_2) {\n                                _this._escapeHeaderValues = true;\n                            }\n                            _this._setupHeartbeat(frame.headers);\n                            _this.onConnect(frame);\n                        },\n                        // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\n                        MESSAGE: function (frame) {\n                            // the callback is registered when the client calls\n                            // `subscribe()`.\n                            // If there is no registered subscription for the received message,\n                            // the default `onUnhandledMessage` callback is used that the client can set.\n                            // This is useful for subscriptions that are automatically created\n                            // on the browser side (e.g. [RabbitMQ's temporary\n                            // queues](http://www.rabbitmq.com/stomp.html)).\n                            var subscription = frame.headers.subscription;\n                            var onReceive = _this._subscriptions[subscription] || _this.onUnhandledMessage;\n                            // bless the frame to be a Message\n                            var message = frame;\n                            var client = _this;\n                            var messageId = _this._connectedVersion === versions_1.Versions.V1_2 ? message.headers.ack : message.headers['message-id'];\n                            // add `ack()` and `nack()` methods directly to the returned frame\n                            // so that a simple call to `message.ack()` can acknowledge the message.\n                            message.ack = function (headers) {\n                                if (headers === void 0) {\n                                    headers = {};\n                                }\n                                return client.ack(messageId, subscription, headers);\n                            };\n                            message.nack = function (headers) {\n                                if (headers === void 0) {\n                                    headers = {};\n                                }\n                                return client.nack(messageId, subscription, headers);\n                            };\n                            onReceive(message);\n                        },\n                        // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\n                        RECEIPT: function (frame) {\n                            var callback = _this._receiptWatchers[frame.headers['receipt-id']];\n                            if (callback) {\n                                callback(frame);\n                                // Server will acknowledge only once, remove the callback\n                                delete _this._receiptWatchers[frame.headers['receipt-id']];\n                            }\n                            else {\n                                _this.onUnhandledReceipt(frame);\n                            }\n                        },\n                        // [ERROR Frame](http://stomp.github.com/stomp-specification-1.2.html#ERROR)\n                        ERROR: function (frame) {\n                            _this.onStompError(frame);\n                        }\n                    };\n                    // used to index subscribers\n                    this._counter = 0;\n                    // subscription callbacks indexed by subscriber's ID\n                    this._subscriptions = {};\n                    // receipt-watchers indexed by receipts-ids\n                    this._receiptWatchers = {};\n                    this._partialData = '';\n                    this._escapeHeaderValues = false;\n                    this._lastServerActivityTS = Date.now();\n                    this.configure(config);\n                }\n                Object.defineProperty(StompHandler.prototype, \"connectedVersion\", {\n                    get: function () {\n                        return this._connectedVersion;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(StompHandler.prototype, \"connected\", {\n                    get: function () {\n                        return this._connected;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                StompHandler.prototype.configure = function (conf) {\n                    // bulk assign all properties to this\n                    Object.assign(this, conf);\n                };\n                StompHandler.prototype.start = function () {\n                    var _this = this;\n                    var parser = new parser_1.Parser(\n                    // On Frame\n                    function (rawFrame) {\n                        var frame = frame_impl_1.FrameImpl.fromRawFrame(rawFrame, _this._escapeHeaderValues);\n                        // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\n                        if (!_this.logRawCommunication) {\n                            _this.debug(\"<<< \" + frame);\n                        }\n                        var serverFrameHandler = _this._serverFrameHandlers[frame.command] || _this.onUnhandledFrame;\n                        serverFrameHandler(frame);\n                    }, \n                    // On Incoming Ping\n                    function () {\n                        _this.debug('<<< PONG');\n                    });\n                    this._webSocket.onmessage = function (evt) {\n                        _this.debug('Received data');\n                        _this._lastServerActivityTS = Date.now();\n                        if (_this.logRawCommunication) {\n                            var rawChunkAsString = (evt.data instanceof ArrayBuffer) ? new TextDecoder().decode(evt.data) : evt.data;\n                            _this.debug(\"<<< \" + rawChunkAsString);\n                        }\n                        parser.parseChunk(evt.data);\n                        // See https://github.com/stomp-js/stompjs/issues/89\n                        // Remove when underlying issue is fixed.\n                        //\n                        // Send a NULL byte, if the last byte of a Text frame was not NULL.\n                        if (_this.appendMissingNULLonIncoming && !(evt.data instanceof ArrayBuffer)) {\n                            if (evt.data[evt.data.length - 1] !== 0) {\n                                var bufferWithNull = (new Uint8Array([0])).buffer;\n                                parser.parseChunk(bufferWithNull);\n                            }\n                        }\n                    };\n                    this._webSocket.onclose = function (closeEvent) {\n                        _this.debug(\"Connection closed to \" + _this._webSocket.url);\n                        _this.onWebSocketClose(closeEvent);\n                        _this._cleanUp();\n                    };\n                    this._webSocket.onerror = function (errorEvent) {\n                        _this.onWebSocketError(errorEvent);\n                    };\n                    this._webSocket.onopen = function () {\n                        // Clone before updating\n                        var connectHeaders = Object.assign({}, _this.connectHeaders);\n                        _this.debug('Web Socket Opened...');\n                        connectHeaders['accept-version'] = _this.stompVersions.supportedVersions();\n                        connectHeaders['heart-beat'] = [_this.heartbeatOutgoing, _this.heartbeatIncoming].join(',');\n                        _this._transmit({ command: 'CONNECT', headers: connectHeaders });\n                    };\n                };\n                StompHandler.prototype._setupHeartbeat = function (headers) {\n                    var _this = this;\n                    if ((headers.version !== versions_1.Versions.V1_1 && headers.version !== versions_1.Versions.V1_2)) {\n                        return;\n                    }\n                    // heart-beat header received from the server looks like:\n                    //\n                    //     heart-beat: sx, sy\n                    var _a = (headers['heart-beat']).split(',').map(function (v) { return parseInt(v, 10); }), serverOutgoing = _a[0], serverIncoming = _a[1];\n                    if ((this.heartbeatOutgoing !== 0) && (serverIncoming !== 0)) {\n                        var ttl = Math.max(this.heartbeatOutgoing, serverIncoming);\n                        this.debug(\"send PING every \" + ttl + \"ms\");\n                        this._pinger = setInterval(function () {\n                            if (_this._webSocket.readyState === WebSocket.OPEN) {\n                                _this._webSocket.send(byte_1.BYTE.LF);\n                                _this.debug('>>> PING');\n                            }\n                        }, ttl);\n                    }\n                    if ((this.heartbeatIncoming !== 0) && (serverOutgoing !== 0)) {\n                        var ttl_1 = Math.max(this.heartbeatIncoming, serverOutgoing);\n                        this.debug(\"check PONG every \" + ttl_1 + \"ms\");\n                        this._ponger = setInterval(function () {\n                            var delta = Date.now() - _this._lastServerActivityTS;\n                            // We wait twice the TTL to be flexible on window's setInterval calls\n                            if (delta > (ttl_1 * 2)) {\n                                _this.debug(\"did not receive server activity for the last \" + delta + \"ms\");\n                                _this._webSocket.close();\n                            }\n                        }, ttl_1);\n                    }\n                };\n                StompHandler.prototype._transmit = function (params) {\n                    var command = params.command, headers = params.headers, body = params.body, binaryBody = params.binaryBody, skipContentLengthHeader = params.skipContentLengthHeader;\n                    var frame = new frame_impl_1.FrameImpl({\n                        command: command,\n                        headers: headers,\n                        body: body,\n                        binaryBody: binaryBody,\n                        escapeHeaderValues: this._escapeHeaderValues,\n                        skipContentLengthHeader: skipContentLengthHeader\n                    });\n                    var rawChunk = frame.serialize();\n                    if (this.logRawCommunication) {\n                        this.debug(\">>> \" + rawChunk);\n                    }\n                    else {\n                        this.debug(\">>> \" + frame);\n                    }\n                    if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\n                        rawChunk = new TextEncoder().encode(rawChunk);\n                    }\n                    if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\n                        this._webSocket.send(rawChunk);\n                    }\n                    else {\n                        var out = rawChunk;\n                        while (out.length > 0) {\n                            var chunk = out.substring(0, this.maxWebSocketChunkSize);\n                            out = out.substring(this.maxWebSocketChunkSize);\n                            this._webSocket.send(chunk);\n                            this.debug(\"chunk sent = \" + chunk.length + \", remaining = \" + out.length);\n                        }\n                    }\n                };\n                StompHandler.prototype.dispose = function () {\n                    var _this = this;\n                    if (this.connected) {\n                        try {\n                            // clone before updating\n                            var disconnectHeaders = Object.assign({}, this.disconnectHeaders);\n                            if (!disconnectHeaders.receipt) {\n                                disconnectHeaders.receipt = \"close-\" + this._counter++;\n                            }\n                            this.watchForReceipt(disconnectHeaders.receipt, function (frame) {\n                                _this._webSocket.close();\n                                _this._cleanUp();\n                                _this.onDisconnect(frame);\n                            });\n                            this._transmit({ command: 'DISCONNECT', headers: disconnectHeaders });\n                        }\n                        catch (error) {\n                            this.debug(\"Ignoring error during disconnect \" + error);\n                        }\n                    }\n                    else {\n                        if (this._webSocket.readyState === WebSocket.CONNECTING || this._webSocket.readyState === WebSocket.OPEN) {\n                            this._webSocket.close();\n                        }\n                    }\n                };\n                StompHandler.prototype._cleanUp = function () {\n                    this._connected = false;\n                    if (this._pinger) {\n                        clearInterval(this._pinger);\n                    }\n                    if (this._ponger) {\n                        clearInterval(this._ponger);\n                    }\n                };\n                StompHandler.prototype.publish = function (params) {\n                    var destination = params.destination, headers = params.headers, body = params.body, binaryBody = params.binaryBody, skipContentLengthHeader = params.skipContentLengthHeader;\n                    var hdrs = Object.assign({ destination: destination }, headers);\n                    this._transmit({\n                        command: 'SEND',\n                        headers: hdrs,\n                        body: body,\n                        binaryBody: binaryBody,\n                        skipContentLengthHeader: skipContentLengthHeader\n                    });\n                };\n                StompHandler.prototype.watchForReceipt = function (receiptId, callback) {\n                    this._receiptWatchers[receiptId] = callback;\n                };\n                StompHandler.prototype.subscribe = function (destination, callback, headers) {\n                    if (headers === void 0) {\n                        headers = {};\n                    }\n                    headers = Object.assign({}, headers);\n                    if (!headers.id) {\n                        headers.id = \"sub-\" + this._counter++;\n                    }\n                    headers.destination = destination;\n                    this._subscriptions[headers.id] = callback;\n                    this._transmit({ command: 'SUBSCRIBE', headers: headers });\n                    var client = this;\n                    return {\n                        id: headers.id,\n                        unsubscribe: function (hdrs) {\n                            return client.unsubscribe(headers.id, hdrs);\n                        }\n                    };\n                };\n                StompHandler.prototype.unsubscribe = function (id, headers) {\n                    if (headers === void 0) {\n                        headers = {};\n                    }\n                    headers = Object.assign({}, headers);\n                    delete this._subscriptions[id];\n                    headers.id = id;\n                    this._transmit({ command: 'UNSUBSCRIBE', headers: headers });\n                };\n                StompHandler.prototype.begin = function (transactionId) {\n                    var txId = transactionId || (\"tx-\" + this._counter++);\n                    this._transmit({\n                        command: 'BEGIN', headers: {\n                            transaction: txId\n                        }\n                    });\n                    var client = this;\n                    return {\n                        id: txId,\n                        commit: function () {\n                            client.commit(txId);\n                        },\n                        abort: function () {\n                            client.abort(txId);\n                        }\n                    };\n                };\n                StompHandler.prototype.commit = function (transactionId) {\n                    this._transmit({\n                        command: 'COMMIT', headers: {\n                            transaction: transactionId\n                        }\n                    });\n                };\n                StompHandler.prototype.abort = function (transactionId) {\n                    this._transmit({\n                        command: 'ABORT', headers: {\n                            transaction: transactionId\n                        }\n                    });\n                };\n                StompHandler.prototype.ack = function (messageId, subscriptionId, headers) {\n                    if (headers === void 0) {\n                        headers = {};\n                    }\n                    headers = Object.assign({}, headers);\n                    if (this._connectedVersion === versions_1.Versions.V1_2) {\n                        headers.id = messageId;\n                    }\n                    else {\n                        headers['message-id'] = messageId;\n                    }\n                    headers.subscription = subscriptionId;\n                    this._transmit({ command: 'ACK', headers: headers });\n                };\n                StompHandler.prototype.nack = function (messageId, subscriptionId, headers) {\n                    if (headers === void 0) {\n                        headers = {};\n                    }\n                    headers = Object.assign({}, headers);\n                    if (this._connectedVersion === versions_1.Versions.V1_2) {\n                        headers.id = messageId;\n                    }\n                    else {\n                        headers['message-id'] = messageId;\n                    }\n                    headers.subscription = subscriptionId;\n                    return this._transmit({ command: 'NACK', headers: headers });\n                };\n                return StompHandler;\n            }());\n            exports.StompHandler = StompHandler;\n            /***/ \n        }),\n        /***/ \"./src/stomp-headers.ts\": \n        /*!******************************!*\\\n          !*** ./src/stomp-headers.ts ***!\n          \\******************************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /**\n             * STOMP headers. Many functions calls will accept headers as parameters.\n             * The headers sent by Broker will be available as [IFrame#headers]{@link IFrame#headers}.\n             *\n             * `key` and `value` must be valid strings.\n             * In addition, `key` must not contain `CR`, `LF`, or `:`.\n             *\n             * Part of `@stomp/stompjs`.\n             */\n            var StompHeaders = /*@__PURE__*/ (function () {\n                function StompHeaders() {\n                }\n                return StompHeaders;\n            }());\n            exports.StompHeaders = StompHeaders;\n            /***/ \n        }),\n        /***/ \"./src/stomp-subscription.ts\": \n        /*!***********************************!*\\\n          !*** ./src/stomp-subscription.ts ***!\n          \\***********************************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /**\n             * Call [Client#subscribe]{@link Client#subscribe} to create a StompSubscription.\n             *\n             * Part of `@stomp/stompjs`.\n             */\n            var StompSubscription = /*@__PURE__*/ (function () {\n                function StompSubscription() {\n                }\n                return StompSubscription;\n            }());\n            exports.StompSubscription = StompSubscription;\n            /***/ \n        }),\n        /***/ \"./src/versions.ts\": \n        /*!*************************!*\\\n          !*** ./src/versions.ts ***!\n          \\*************************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            \"use strict\";\n            Object.defineProperty(exports, \"__esModule\", { value: true });\n            /**\n             * Supported STOMP versions\n             *\n             * Part of `@stomp/stompjs`.\n             */\n            var Versions = /*@__PURE__*/ (function () {\n                /**\n                 * Takes an array of string of versions, typical elements '1.0', '1.1', or '1.2'\n                 *\n                 * You will an instance if this class if you want to override supported versions to be declared during\n                 * STOMP handshake.\n                 */\n                function Versions(versions) {\n                    this.versions = versions;\n                }\n                /**\n                 * Used as part of CONNECT STOMP Frame\n                 */\n                Versions.prototype.supportedVersions = function () {\n                    return this.versions.join(',');\n                };\n                /**\n                 * Used while creating a WebSocket\n                 */\n                Versions.prototype.protocolVersions = function () {\n                    return this.versions.map(function (x) { return \"v\" + x.replace('.', '') + \".stomp\"; });\n                };\n                /**\n                 * Indicates protocol version 1.0\n                 */\n                Versions.V1_0 = '1.0';\n                /**\n                 * Indicates protocol version 1.1\n                 */\n                Versions.V1_1 = '1.1';\n                /**\n                 * Indicates protocol version 1.2\n                 */\n                Versions.V1_2 = '1.2';\n                /**\n                 * @internal\n                 */\n                Versions.default = new Versions([Versions.V1_0, Versions.V1_1, Versions.V1_2]);\n                return Versions;\n            }());\n            exports.Versions = Versions;\n            /***/ \n        }),\n        /***/ 0: \n        /*!****************************!*\\\n          !*** multi ./src/index.ts ***!\n          \\****************************/\n        /*! no static exports found */\n        /***/ (function (module, exports, __webpack_require__) {\n            module.exports = __webpack_require__(/*! /home/kdeepak/MyWork/Tech/stomp/stompjs/src/index.ts */ \"./src/index.ts\");\n            /***/ \n        })\n        /******/ \n    });\n});\n//# sourceMappingURL=stomp.umd.js.map\n",null]}